import { Component, ViewChild, ElementRef, signal, OnInit, inject, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterLink } from '@angular/router';
import * as faceapi from 'face-api.js';
import { RecommendationService, ProductRecommendation } from '../services/recommendation.service';
import { CartService } from '../services/cart.service';
import { DeepseekAiService, FaceAnalysisData, AIAnalysisResult } from '../services/deepseek-ai.service';
import { Subject, takeUntil } from 'rxjs';

@Component({
  selector: 'app-face-analysis',
  standalone: true,
  imports: [CommonModule, RouterLink],
  templateUrl: './face-analysis.component.html',
  styleUrl: './face-analysis.component.css'
})
export class FaceAnalysisComponent implements OnInit, OnDestroy {
  @ViewChild('videoElement') videoElement!: ElementRef<HTMLVideoElement>;

  // Signals pour l'√©tat r√©actif
  currentStep = signal<'permission' | 'camera' | 'captured' | 'analyzing' | 'ai-analyzing' | 'results'>('permission');
  cameraReady = signal(false);
  errorMessage = signal<string | null>(null);
  modelsLoaded = signal(false);
  faceDetected = signal(false);
  analysisResults = signal<any>(null);
  aiAnalysisResults = signal<AIAnalysisResult | null>(null);
  productRecommendations = signal<ProductRecommendation[]>([]);
  personalizedTips = signal<string[]>([]);

  private stream: MediaStream | null = null;
  private capturedImageData: string | null = null;
  private detectionInterval: any;
  private destroy$ = new Subject<void>();
  private recommendationService = inject(RecommendationService);
  private cartService = inject(CartService);
  private deepseekAI = inject(DeepseekAiService);

  async ngOnInit() {
    // Charger les mod√®les face-api.js au d√©marrage
    await this.loadModels();
    
    // Test de connexion DeepSeek AI
    console.log('üîó Test de connexion DeepSeek...');
    const connectionOk = await this.deepseekAI.testConnection();
    console.log('ü§ñ DeepSeek connect√©:', connectionOk ? '‚úÖ' : '‚ùå');
  }

  async loadModels() {
    try {
      console.log('üß† Chargement des mod√®les IA...');
      
      // Charger les mod√®les depuis CDN (plus fiable)
      const MODEL_URL = 'https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights';
      
      await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
      await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);
      
      this.modelsLoaded.set(true);
      console.log('‚úÖ Mod√®les IA charg√©s avec succ√®s !');
      
    } catch (error) {
      console.error('‚ùå Erreur chargement mod√®les:', error);
      this.errorMessage.set('Erreur de chargement des mod√®les IA');
    }
  }

  async startCamera() {
    try {
      this.errorMessage.set(null);
      
      if (!this.modelsLoaded()) {
        this.errorMessage.set('Les mod√®les IA sont en cours de chargement...');
        return;
      }

      // Demander l'acc√®s √† la cam√©ra
      this.stream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: 640 },
          height: { ideal: 480 },
          facingMode: 'user'
        },
        audio: false
      });

      // Attendre que la vue soit mise √† jour
      setTimeout(() => {
        if (this.videoElement) {
          this.videoElement.nativeElement.srcObject = this.stream;
          this.videoElement.nativeElement.onloadedmetadata = () => {
            this.cameraReady.set(true);
            this.startFaceDetection();
          };
        }
      }, 100);

      this.currentStep.set('camera');
      
    } catch (error) {
      console.error('Erreur acc√®s cam√©ra:', error);
      this.errorMessage.set('Impossible d\'acc√©der √† la cam√©ra. V√©rifiez les permissions.');
    }
  }

  startFaceDetection() {
    if (!this.videoElement || !this.modelsLoaded()) return;

    const video = this.videoElement.nativeElement;
    
    // V√©rifier la d√©tection toutes les 500ms
    this.detectionInterval = setInterval(async () => {
      try {
        const detections = await faceapi
          .detectAllFaces(video, new faceapi.TinyFaceDetectorOptions())
          .withFaceLandmarks();

        if (detections.length > 0) {
          this.faceDetected.set(true);
          console.log('üë§ Visage d√©tect√© !', detections[0]);
        } else {
          this.faceDetected.set(false);
        }
      } catch (error) {
        console.error('Erreur d√©tection:', error);
      }
    }, 500);
  }

  stopFaceDetection() {
    if (this.detectionInterval) {
      clearInterval(this.detectionInterval);
      this.detectionInterval = null;
    }
  }

  async capturePhoto() {
    if (!this.videoElement || !this.cameraReady()) return;

    const video = this.videoElement.nativeElement;
    
    // Cr√©er un canvas temporaire pour la capture
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    if (!ctx) return;

    // D√©finir la taille du canvas
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    // Dessiner l'image de la vid√©o sur le canvas (avec effet miroir)
    ctx.scale(-1, 1);
    ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);

    // Sauvegarder l'image
    this.capturedImageData = canvas.toDataURL('image/jpeg', 0.8);

    // Arr√™ter la cam√©ra et la d√©tection
    this.stopCamera();
    this.stopFaceDetection();

    // Passer √† l'√©tape suivante
    this.currentStep.set('captured');
  }

  stopCamera() {
    if (this.stream) {
      this.stream.getTracks().forEach(track => track.stop());
      this.stream = null;
    }
    this.cameraReady.set(false);
    this.faceDetected.set(false);
    this.stopFaceDetection();
  }

  getCapturedImage(): string {
    return this.capturedImageData || '';
  }

  retakePhoto() {
    this.capturedImageData = null;
    this.startCamera();
  }

  // üéØ M√âTHODE AM√âLIOR√âE : Analyse compl√®te de la photo
  async analyzePhoto() {
    if (!this.capturedImageData) return;

    this.currentStep.set('analyzing');

    try {
      // Cr√©er une image √† partir des donn√©es captur√©es
      const img = new Image();
      img.src = this.capturedImageData;

      await new Promise(resolve => {
        img.onload = resolve;
      });

      // Analyser l'image avec face-api.js
      const detections = await faceapi
        .detectAllFaces(img, new faceapi.TinyFaceDetectorOptions())
        .withFaceLandmarks();

      if (detections.length === 0) {
        this.errorMessage.set('Aucun visage d√©tect√© dans l\'image. Veuillez reprendre la photo.');
        this.currentStep.set('captured');
        return;
      }

      // Analyser les caract√©ristiques du visage
      const detection = detections[0];
      const landmarks = detection.landmarks;
      
      // Calculer des m√©triques basiques
      const faceBox = detection.detection.box;
      const faceWidth = faceBox.width;
      const faceHeight = faceBox.height;
      
      console.log('üìê Dimensions visage:', { faceWidth, faceHeight, ratio: faceHeight/faceWidth });
      
      // Analyser la forme du visage
      const jawLine = landmarks.getJawOutline();
      const nose = landmarks.getNose();
      const leftEye = landmarks.getLeftEye();
      const rightEye = landmarks.getRightEye();
      const mouth = landmarks.getMouth();
      
      // üéØ NOUVELLE APPROCHE : Analyse bas√©e sur les vraies coordonn√©es + timestamp
      const analysisData = this.analyzeDetailedFeatures(landmarks, faceBox, Date.now());
      
      console.log('üîç Donn√©es d\'analyse d√©taill√©es:', analysisData);
      console.log('‚è∞ Timestamp d\'analyse:', Date.now());

      const results = {
        faceDetected: true,
        confidence: detection.detection.score,
        estimatedAge: analysisData.age,
        skinType: analysisData.skinType,
        faceShape: analysisData.faceShape,
        recommendations: this.generateRecommendations(analysisData.age, analysisData.skinType),
        debugInfo: analysisData
      };

      this.analysisResults.set(results);
      console.log('üéØ R√©sultats d\'analyse:', results);

      // ü§ñ NOUVEAU : Analyse avec DeepSeek AI
      console.log('ü§ñ D√©marrage analyse IA avanc√©e...');
      this.currentStep.set('ai-analyzing');

      // Pr√©parer les donn√©es pour l'IA
      const faceData: FaceAnalysisData = {
        faceWidth,
        faceHeight,
        eyeDistance: Math.abs(rightEye[0].x - leftEye[3].x),
        mouthWidth: Math.abs(mouth[6].x - mouth[0].x),
        noseHeight: Math.abs(nose[6].y - nose[0].y),
        jawWidth: Math.abs(jawLine[16].x - jawLine[0].x),
        noseToEyeRatio: Math.abs(nose[0].y - ((leftEye[1].y + leftEye[2].y) / 2)) / faceHeight,
        faceRatio: faceHeight / faceWidth,
        jawRatio: Math.abs(jawLine[16].x - jawLine[0].x) / faceWidth,
        confidence: detection.detection.score
      };

      try {
        // Analyser avec DeepSeek AI
        const aiResults = await this.deepseekAI.analyzeWithAI(faceData);
        this.aiAnalysisResults.set(aiResults);
        
        console.log('ü§ñ Analyse IA termin√©e:', aiResults);

        // üõí Obtenir les vraies recommandations produits bas√©es sur l'IA
        const recommendations = await this.recommendationService.getRecommendations({
          estimatedAge: aiResults.estimatedAge,
          skinType: aiResults.skinType,
          faceShape: aiResults.faceShape,
          confidence: aiResults.confidence
        });
        this.productRecommendations.set(recommendations);
        
        // üí° Utiliser les conseils de l'IA
        this.personalizedTips.set(aiResults.beautyTips);

        console.log('üõçÔ∏è Recommandations produits IA:', recommendations);

      } catch (error) {
        console.error('‚ùå Erreur analyse IA:', error);
        // Fallback sur l'analyse classique
        const recommendations = await this.recommendationService.getRecommendations(results);
        this.productRecommendations.set(recommendations);
        
        const tips = this.recommendationService.getPersonalizedTips(results);
        this.personalizedTips.set(tips);
      }

      // Transition vers les r√©sultats
      setTimeout(() => {
        this.currentStep.set('results');
      }, 3000);

    } catch (error) {
      console.error('‚ùå Erreur analyse:', error);
      this.errorMessage.set('Erreur lors de l\'analyse. Veuillez r√©essayer.');
      this.currentStep.set('captured');
    }
  }

  // üéØ NOUVELLE M√âTHODE : Analyse d√©taill√©e avec variation
  private analyzeDetailedFeatures(landmarks: any, faceBox: any, timestamp?: number) {
    try {
      // R√©cup√©rer les points cl√©s
      const jawLine = landmarks.getJawOutline();
      const nose = landmarks.getNose();
      const leftEye = landmarks.getLeftEye();
      const rightEye = landmarks.getRightEye();
      const mouth = landmarks.getMouth();

      // Calculer des m√©triques uniques pour chaque visage
      const eyeCenter1 = { x: (leftEye[0].x + leftEye[3].x) / 2, y: (leftEye[1].y + leftEye[2].y) / 2 };
      const eyeCenter2 = { x: (rightEye[0].x + rightEye[3].x) / 2, y: (rightEye[1].y + rightEye[2].y) / 2 };
      
      // Distance entre les yeux
      const eyeDistance = Math.sqrt(
        Math.pow(eyeCenter2.x - eyeCenter1.x, 2) + Math.pow(eyeCenter2.y - eyeCenter1.y, 2)
      );
      
      // Largeur de la bouche
      const mouthWidth = Math.abs(mouth[6].x - mouth[0].x);
      
      // Hauteur du nez
      const noseHeight = Math.abs(nose[6].y - nose[0].y);
      
      // Largeur de la m√¢choire
      const jawWidth = Math.abs(jawLine[16].x - jawLine[0].x);
      
      // Position du nez par rapport aux yeux
      const noseToEyeRatio = Math.abs(nose[0].y - eyeCenter1.y) / faceBox.height;
      
      // Ratio visage
      const faceRatio = faceBox.height / faceBox.width;
      
      console.log('üìä M√©triques faciales:', {
        eyeDistance,
        mouthWidth,
        noseHeight,
        jawWidth,
        noseToEyeRatio,
        faceRatio
      });

      // Cr√©er un "hash" unique du visage pour la coh√©rence + variation temporelle
      const baseHash = Math.floor((eyeDistance + mouthWidth + noseHeight + jawWidth) * 1000) % 1000;
      const timeVariation = timestamp ? (timestamp % 100) : 0;
      const faceHash = (baseHash + timeVariation) % 1000;
      
      console.log('üîë Hash du visage:', faceHash, '(base:', baseHash, '+ time:', timeVariation, ')');

      // Estimation d'√¢ge bas√©e sur plusieurs facteurs (√âQUILIBR√â)
      let ageScore = 0;
      
      // Plus la distance ≈ìil-nez est grande, plus √¢g√© (MOD√âR√â)
      if (noseToEyeRatio > 0.35) ageScore += 25;
      else if (noseToEyeRatio > 0.25) ageScore += 15;
      else if (noseToEyeRatio > 0.15) ageScore += 10;
      else ageScore += 5;
      
      // M√¢choire : plus affaiss√©e = plus √¢g√© (MOD√âR√â)
      const jawRatio = jawWidth / faceBox.width;
      if (jawRatio > 0.85) ageScore += 5;
      else if (jawRatio > 0.75) ageScore += 10;
      else if (jawRatio > 0.65) ageScore += 15;
      else ageScore += 20;
      
      // Ratio du visage (R√âDUIT)
      if (faceRatio > 1.4) ageScore += 10;
      else if (faceRatio < 1.0) ageScore += 15;
      else ageScore += 5;

      // Facteur de "complexit√©" faciale (R√âDUIT)
      const complexityFactor = (eyeDistance + mouthWidth + noseHeight) / 3;
      if (complexityFactor > 75) ageScore += 10;
      else if (complexityFactor > 65) ageScore += 5;
      else ageScore += 0;

      // Ajustement bas√© sur le hash (R√âDUIT)
      const ageVariation = (faceHash % 20) - 10;
      ageScore += ageVariation;

      console.log('üë¥ Calcul d\'√¢ge d√©taill√©:', {
        noseToEyeRatio,
        jawRatio,
        faceRatio,
        complexityFactor,
        ageVariation,
        ageScore
      });

      // D√©terminer l'√¢ge avec des seuils √âQUILIBR√âS
      let estimatedAge;
      if (ageScore < 20) estimatedAge = "18-25 ans";
      else if (ageScore < 35) estimatedAge = "25-35 ans";
      else if (ageScore < 50) estimatedAge = "35-50 ans";
      else if (ageScore < 65) estimatedAge = "50-65 ans";
      else estimatedAge = "65+ ans";

      // Type de peau bas√© sur les caract√©ristiques
      let skinType;
      const skinFactor = (eyeDistance + mouthWidth) % 6;
      const skinTypes = [
        "Peau claire et sensible",
        "Peau normale √©quilibr√©e", 
        "Peau mate naturelle",
        "Peau mixte",
        "Peau claire √† tendance s√®che",
        "Peau fonc√©e riche"
      ];
      skinType = skinTypes[Math.floor(skinFactor)];

      // Forme du visage
      let faceShape;
      if (faceRatio > 1.5) faceShape = "Ovale allong√©";
      else if (faceRatio > 1.3 && jawRatio > 0.75) faceShape = "Rectangle";
      else if (faceRatio < 1.1) faceShape = "Rond";
      else if (jawRatio > 0.85) faceShape = "Carr√©";
      else if (jawRatio < 0.65) faceShape = "Triangle invers√©";
      else faceShape = "Ovale classique";

      return {
        age: estimatedAge,
        skinType: skinType,
        faceShape: faceShape,
        ageScore,
        faceHash,
        metrics: {
          eyeDistance,
          mouthWidth,
          noseHeight,
          jawWidth,
          noseToEyeRatio,
          faceRatio,
          jawRatio
        }
      };

    } catch (error) {
      console.error('‚ùå Erreur analyse d√©taill√©e:', error);
      return {
        age: "25-35 ans",
        skinType: "Peau normale",
        faceShape: "Ovale",
        ageScore: 35,
        faceHash: 0,
        metrics: {}
      };
    }
  }

  private generateRecommendations(age: string, skinType: string): string[] {
    const recommendations = [];

    console.log('üí° G√©n√©ration recommandations pour:', { age, skinType });

    // Recommandations bas√©es sur l'√¢ge avec plus de vari√©t√©
    if (age.includes("18-25")) {
      const youngSkinOptions = [
        ["Gel nettoyant purifiant", "Cr√®me hydratante l√©g√®re", "Protection solaire SPF 50"],
        ["Mousse nettoyante douce", "S√©rum hydratant", "√âcran solaire quotidien"],
        ["Nettoyant sans savon", "Hydratant matifiant", "Protection UV invisible"]
      ];
      const selectedYoung = youngSkinOptions[Math.floor(Math.random() * youngSkinOptions.length)];
      recommendations.push(...selectedYoung);
      
    } else if (age.includes("25-35")) {
      const preventiveOptions = [
        ["S√©rum vitamine C", "Cr√®me anti-√¢ge pr√©ventive", "Contour yeux hydratant"],
        ["Antioxydant quotidien", "Hydratant raffermissant", "Soin contour des yeux"],
        ["S√©rum √©clat", "Cr√®me jour anti-√¢ge", "Gel contour yeux"]
      ];
      const selectedPreventive = preventiveOptions[Math.floor(Math.random() * preventiveOptions.length)];
      recommendations.push(...selectedPreventive);
      
    } else if (age.includes("35-50")) {
      const antiAgingOptions = [
        ["S√©rum anti-rides intensif", "Cr√®me nuit r√©g√©n√©rante", "Soin yeux anti-√¢ge"],
        ["Traitement anti-rides", "Cr√®me raffermissante", "Contour yeux liftant"],
        ["S√©rum peptides", "Soin nuit r√©parateur", "Cr√®me yeux anti-poches"]
      ];
      const selectedAntiAging = antiAgingOptions[Math.floor(Math.random() * antiAgingOptions.length)];
      recommendations.push(...selectedAntiAging);
      
    } else {
      const matureOptions = [
        ["Cr√®me anti-√¢ge premium", "S√©rum raffermissant", "Masque r√©g√©n√©rant"],
        ["Soin anti-rides global", "Cr√®me restructurante", "Traitement intensif"],
        ["Cr√®me haute performance", "S√©rum lift", "Soin r√©parateur"]
      ];
      const selectedMature = matureOptions[Math.floor(Math.random() * matureOptions.length)];
      recommendations.push(...selectedMature);
    }

    return recommendations.slice(0, 4);
  }

  resetAnalysis() {
    this.currentStep.set('permission');
    this.capturedImageData = null;
    this.errorMessage.set(null);
    this.analysisResults.set(null);
    this.aiAnalysisResults.set(null);
    this.productRecommendations.set([]);
    this.personalizedTips.set([]);
    this.faceDetected.set(false);
    this.stopCamera();
  }

  // üõí NOUVELLE M√âTHODE : Ajouter un produit au panier
  addToCart(recommendation: ProductRecommendation) {
    this.cartService.addToCart(recommendation.product, recommendation.product.defaultSize, 1);
    console.log('‚úÖ Produit ajout√© au panier:', recommendation.product.title);
  }

  ngOnDestroy() {
    this.stopCamera();
    this.stopFaceDetection();
    this.destroy$.next();
    this.destroy$.complete();
  }
}